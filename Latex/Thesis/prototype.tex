\chapter{Prototyp}
\section{Cele i zakres}
Jako pocz¹tkowy etap przygotowania projektu stworzono prototyp gry. Zosta³ on przygotowany w kilku celach.
\begin{enumerate}
    \item Zapoznanie z mo¿liwoœciami i ograniczeniami silnika. 
    \item Okreœlenie trudnoœci przygotowania warstwy sieciowej.
    \item Zapoznanie z jêzykiem skryptowym GDScript. 
\end{enumerate}

W ramach prototypu zaimplementowano jedynie bardzo podstawowe mechaniki: poruszanie, celowanie i strzelanie. System sieciowy równie¿ zaimplementowano w uproszczonej formie, nie implementuj¹c równie¿ wszystkich mechanik sieciowo - jedynie poruszanie i celowanie.

Na tym etapie nie przygotowano ¿adnych grafik, jako modele i poziom zosta³y wykorzystane jedynie proste figury geometryczne generowane w silniku.

\section{Mechaniki}
W ramach prototypu wprowadzone zosta³y implementacje poruszania/sterowania, celowania i strzelania.

\subsection{Przygotowanie projektu}
Aby móc programowaæ i testowaæ implementacje mechanik niezbêdne by³o przygotowanie œwiata gry oraz postaci gracza. 

Œwiat gry zosta³ zbudowany z przeskalowanych prostopad³oœcianów dzia³aj¹cych jako pod³o¿e, œciany ograniczaj¹ce poziom oraz przeszkody w poziomie. Wykorzystano równie¿ figury CSG (\emph{Constructive Solid Geometry} - ang. Konstrulcyjna Geometria Bry³owa) w celu stworzenia bardziej skomplikowanej przeszkody. Bry³y tego rodzaju mo¿na ³¹czyæ w spójne figury z pomoc¹ takich operacji jak suma, ró¿nica czy czêœæ wspólna.

Awatar gracza zosta³ z³o¿ony z dwóch czêœci - cia³a (ang. \emph{body}) i g³owy (ang. \emph{head}). S¹ to jedynie nazwy dla prostego rozró¿nienia kad³uba od wie¿yczki wraz z luf¹. Taki podzia³ zosta³ wprowadzony w celu prostszego i niezale¿ego sterowania transformacj¹ oraz rotacj¹ tych elementów. Ca³oœæ zosta³a przygotowana z wykorzystaniem trzech bry³ - prostopad³oœcianu dla cia³a, kuli dla wie¿yczki oraz walca dla lufy.

TODO: screen z modelem z prototypu

TODO: consider opisaæ sceny godot - system wêz³ów i drzewa, obiekty, skrypty

\subsection{Poruszanie}
Zosta³ wprowadzony schemat sterowania zgodny z ustaleniami sekcji \ref{sec:steering_concept} oraz tabeli TODO: ref tabelkê ze sterowaniem. 

Postaæ gracza poruszana jest jedynie w przypadku je¿eli odpowiedni przycisk jest przytrzymywany. W tym celu w procesie fizycznym wykonywane jest sprawdzenie wprowadzanych przez gracza poleceñ. 

Proces fizyczny to metoda w skryptach Godota, wywo³ywana co ustalony czas, niezale¿ny od wyœwietlanych klatek. Pozwala to na ujednolicenie dzia³ania krytycznych czêœci kodu w przypadku gdy scena i klatka mo¿e byæ generowana d³u¿ej ni¿ zwykle.

Poniewa¿ ruch w osi przód-ty³ i obrót w prawo-lewo s¹ ró¿nymi zachowaniami wejœcia z nimi zwi¹zane zosta³y zapisane do oddzielnych zmiennych. Ponadto, poniewa¿ jednoczesny obrót lub ruch w obie strony siê wykluczaj¹, wartoœæ tych dwóch poleceñ zostaje od siebie odjêta. \ref{lst:getting_input}

\begin{lstlisting}[language=python,caption=Kod pobieraj¹cy polecenia gracza, label=lst:getting_input,basicstyle=\footnotesize\ttfamily]
var forward_input = int(Input.is_action_pressed("Forward")) - int(Input.is_action_pressed("Back"))
var turn_input = int(Input.is_action_pressed("Left")) - int(Input.is_action_pressed("Right"))
\end{lstlisting}

\texttt{Input} jest obiektem tworzonym przez silnik, singletonem, który zarz¹dza interfejsami poleceñ gracza takimi jak klawiatura i mysz. Zamiast metody \texttt{is\_action\_pressed}, która sprawdza aktualny stan akcji, mo¿liwe jest równie¿ wykorzystanie metody \texttt{get\_axis}, która pozwala skróciæ powy¿szy zapis zachowuj¹c ten sam rezultat. Akcje ``Forward'', ``Back'', ``Left'' i ``Right'' zosta³y rêcznie stworzone i zmapowane do odpowiednich wejœæ z tabeli (TODO: ref tabelê wejœæ), korzystaj¹c z mapowania wejœcia w ustawieniach projektu Godota.

W skrypcie gracza zdefiniowane zosta³y atrybuty niezbêdne do implementacji poruszania - prêdkoœæ maksymalna i aktualna poruszania oraz prêdkoœæ k¹towa maksymalna i aktualna obrotu. Aktualna prêdkoœæ poruszania jest wartoœci¹ wektorow¹, pozosta³e zaœ s¹ wartoœciami skalarnymi. Zmienne przechowuj¹ce wartoœci maksymalne s¹ zdefiniowane wykorzystaniem s³owa kluczowego \texttt{export} co pozwala na edytowanie ich w oknie silnika Godot.

Jako oœ przód-ty³ wykorzystano oœ $z$ modelu gracza, gdzie przód jest zwrócony zgodnie z dodatni¹ czêœci¹ osi. W celu poruszenia ca³ego obiektu gracza wywo³ana zostaje funkcja \texttt{move\_and\_slide}, która s³u¿y do przemieszczania obiektów z uwzglêdnieniem kolizji. Do obrócenia modelu wykorzystano metodê \texttt{rotate\_y}, poniewa¿ w silniku Godot oœ ``y'' jest osi¹ pionow¹.

Aby awatar wraz z otoczeniem mog³y byæ stale widoczne dla gracza kamera musi poruszaæ siê wraz z nim. Zosta³a podjêta decyzja o wykorzystaniu kamery trzecioosobowej, tj. takiej, która pod¹¿a za graczem i widzi równie¿ jego model, w odró¿nieniu od kamery pierwszoosobowej, która widzi œwiat z perspektywy gracza. Wybrano wbudowan¹ w silnik Godot kamerê interpolowan¹ (\texttt{InterpolatedCamera}). Jest to kamera, która porusza siê p³ynnie tak, aby jej po³o¿enie pokrywa³o siê z jej celem. Cel kamery jest równie¿ obiektem o odpowiedniej pozycji i rotacji.

Cel oraz kamera zosta³y dodane do sceny œwiata, a nie gracza, aby na etapie dodawania systemu sieciowego (\ref{sec:network_prototype}) móc unikn¹æ problemu wielu niewykorzystanych obiektów. 

W skrypcie œwiata, w procesie fizycznym cel kamery jest przenoszony w pozycjê o odpowiednich koordynatach. kamera bêdzie automatycznie przemieszcza³a siê tak, aby œledziæ ten punkt, jednak jej rotacja równie¿ ustawiana programistycznie, poprzez wykorzystanie metody \texttt{look\_at}. 

\subsection{Celowanie}

Celowanie zosta³o zaimplementowane zgodnie z sekcj¹ \ref{sec:shooting_concept}. W tym celu nale¿y wykonaæ nastêpuj¹ce kroki:
\begin{enumerate}
    \item\label{pt:get_mouse} Pobraæ pozycjê myszy w oknie gry;
    \item Pobraæ pozycjê kamery w œwiecie gry;
    \item Wyznaczyæ promieñ przechodz¹cy od kamery w kierunku wskazywanym przez mysz;
    \item\label{pt:get_ray_intersection} Zbadaæ przeciêcia powy¿szego promienia z obiektami œwiata gry;
    \item Wycelowaæ w kierunku wyznaczonego punktu przeciêcia.  
\end{enumerate}

Kod funkcji realizuj¹cej punkty \ref{pt:get_mouse}-\ref{pt:get_ray_intersection} zosta³ zamieszczony w listingu \ref{lst:mouse_to_world}.

\begin{lstlisting}[language=python,caption=Funkcja rzutuj¹ca mysz na œwiat gry, label=lst:mouse_to_world,basicstyle=\footnotesize\ttfamily]
func mousePositionToWorldPosition():
  var space_state = get_world().direct_space_state
  var mouse_pos = get_viewport().get_mouse_position()

  var camera = get_tree().root.get_camera()
  if camera == null:
    return null

  var ray_origin = camera.global_translation
  var ray_direction = camera.project_position(mouse_pos, 300)

  var ray_array = space_state.intersect_ray(ray_origin, ray_direction)

  if ray_array.has("position"):
    return ray_array["position"]
  return null
\end{lstlisting}

Je¿eli zostanie znaleziony punkt przeciêcia promienia z obiektami œwiata, ca³a ``g³owa'' modelu gracza jest obracana w jego kierunku. W prototypie punkt ten jest równie¿ wizualizowany kul¹, która siê w nim pojawia. Pomog³o to w zniwelowaniu b³êdów wynikaj¹cych z ró¿nicy miêdzy przestrzeni¹ lokaln¹ modelu gracza a globaln¹. 

\subsection{Strzelanie}
Stworzony zosta³ obiekt pocisku. Jego modelem jak i kszta³tem kolizji jest figura kapsu³y. 

Aby mo¿liwe by³o strzelanie nale¿a³o dodaæ do obiektu postaci gracza punkt, w którym tworzone bêd¹ pociski. Zosta³ on umieszczony na koñcu lufy i przypisany jako dziecko tego obiektu. W ten sposób punkt ten bêdzie przemieszcza³ siê tak samo jak jego rodzic. Do skryptu gracza zosta³a równie¿ dodana zmienna przechowuj¹ca referencjê do sceny pocisku.

Do skryptu gracza dodano tak¿e funkcjê strza³u, oraz kod przyjmuj¹cy polecenie strza³u z myszy. Podobnie jak akcje poruszania, akcja strza³u zosta³a zmapowana w ustawieniach projektu. Z perspektywy gracza strza³ polega jedynie na stworzeniu instancji sceny pocisku, umieszczeniu jej w punkcie strza³u na koñcu lufy oraz przypisaniu jej do œwiata gry. Pociski nie mog¹ byæ zapisywane jako dzieci gracza, poniewa¿ wtedy przemieszcza³yby siê razem z nim.

Do skryptu pocisku dodano sta³e okreœlaj¹ce szybkoœæ poruszania oraz limit czasu istnienia obiektu. W momencie utworzenia instancji pocisku licznik czasu istnienia zaczyna odliczaæ liczbê sekund równ¹ limitowi. W przypadku zakoñczenia licznika obiekt pocisku jest niszczony. W procesie fizycznym pocisk przemieszczany jest z odpowiedni¹ szybkoœci¹ w jego lokalnym kierunku $+z$. Po wykryciu zderzenia pocisk jest niszczony.   

\section{System sieciowy}\label{sec:network_prototype}

Podstawowy system sieciowy zosta³ zaimplementowany z wykorzystaniem poradnika (cite https://youtu.be/lpkaMKE081M). Ostateczna implementacja zosta³a jednak dostosowana do przygotowywanego rozwi¹zania, poniewa¿ projekt z poradnika jest tworzony z wykorzystaniem grafiki 2D.

Do projektu dodano pusty wêze³ statyczny maj¹cy przechowywaæ graczy w drzewie. Ponadto dodano menu startowe (Rys. \ref{fig:prototype_menu}). Stworzono równie¿ dwa skrypty globalne oraz zmodyfikowano skrypt gracza.

\begin{figure}
    \centering
    \includegraphics[width=.9\linewidth]{Images/prototype/prototype_net_menu.png}
    \caption{Menu startowe prototypu po wprowadzeniu systemu sieciowego}
    \label{fig:prototype_menu}
\end{figure}

Na interfejsie menu widoczne s¹ dwa przyciski. Przycisk ``Create Server'' powoduje rozpoczêcie gry jako host. Gra hostowana jest wtedy na adresie IP maszyny u¿ytkownika. Przycisk ``Join Server'' powoduje rozpoczêcie gry na serwerze, którego adres IP wpisany jest w pole tekstowe. W prototypie nie zosta³y zastosowane ¿adne techniki obrony przed wpisaniem niepoprawnego adresu IP ani próby po³¹czenia z nieistniej¹cym serwerem.

Skrypt globalny \texttt{Network} jest odpowiedzialny za po³¹czenia sieciowe. Korzysta on z wysokopoziomowego interfejsu sieciowego Godota. 

Podczas uruchomienia gry ten skrypt pobiera adres IP maszyny. Nastêpnie ³¹czy siê z sygna³ami zwi¹zanymi ze zmianami sieciowego stanu gry (Listing \ref{lst:signal_connecting_prototype}). 


\begin{lstlisting}[language=python,caption=Pod³¹czanie do najwa¿niejszych sygna³ów sieciowych, label=lst:signal_connecting_prototype ,basicstyle=\footnotesize\ttfamily]
get_tree().connect("connected_to_server", self, "_connected_to_server")
get_tree().connect("server_disconnected", self, "_server_disconnected")
get_tree().connect("network_peer_connected", self, "_player_connected")
get_tree().connect("network_peer_disconnected",self,"_player_disconnected")
\end{lstlisting}

Poni¿ej zosta³y opisane sygna³y oraz przypisane do nich funkcje:
\begin{itemize}
    \item \texttt{connected\_to\_server} zostaje emitowany gdy gra po³¹czy siê z serwerem. Funkcja tworzy instancjê w³asnej postaci gracza.
    \item \texttt{server\_disconnected} zostaje emitowany gdy gra zostanie roz³¹czona z serwerem; W prototypie funkcja jedynie loguje wydarzenie.
    \item \texttt{network\_peer\_connected} zostaje emitowany gdy inny gracz zostaje pod³¹czony do gry. W sytuacji gdy gracz pierwszy raz pod³¹cza siê do serwera ten sygna³ emitowany jest dla wszystkich graczy ju¿ na serwerze. Funkcja tworzy instancjê postaci nowo pod³¹czonego gracza.
    \item \texttt{network\_peer\_disconnected} zostaje emitowany gdy inny gracz od³¹cza siê od serwera. Funkcja usuwa postaæ roz³¹czonego gracza.
\end{itemize}

Ponadto w skrypcie \texttt{Network} zdefiniowane s¹ funkcje \texttt{create\_server} i \texttt{join\_server} s³u¿¹ce do, odpowiednio, stworzenia serwera i do³¹czenia do serwera. W tym celu wykorzystana zosta³a klasa \texttt{NetworkedMultiplayerENet}, implementuj¹ca warstwê sieciow¹ korzystaj¹c¹ z po³¹czenia UDP.


\begin{lstlisting}[language=python,caption=Funkcja inicjuj¹ca serwer gry., label=lst:create_server_prototype ,basicstyle=\footnotesize\ttfamily]
func create_server() -> void:
  server = NetworkedMultiplayerENet.new()
  server.create_server(DEAFAULT_PORT, MAX_CLIENTS)
  get_tree().set_network_peer(server)
\end{lstlisting}
\begin{lstlisting}[language=python,caption=Funkcja ³¹cz¹ca do serwera gry., label=lst:join_server_prototype ,basicstyle=\footnotesize\ttfamily]
func join_server() -> void:
  client = NetworkedMultiplayerENet.new()
  client.create_client(ip_address, DEAFAULT_PORT)
  get_tree().set_network_peer(client)
\end{lstlisting}

Skrypt \texttt{Global} sk³ada siê z metod u³atwiaj¹cych instancjonowanie graczy. S¹ one wykorzystywane podczas rozpoczynania gry.

Do sceny gracza dodano wêz³y \texttt{Timer} - odliczaj¹cy okres synchronizacji z serwerem i \texttt{Tween} - pozwalaj¹cy p³ynnie przekszta³caæ w³aœciwoœci wêz³a. Do skryptu gracza dodano zmienne oznaczone s³owem kluczowym typu \texttt{puppet} - s¹ to wartoœci, które bêd¹ synchronizowane przez sieæ. Takie zmienne stworzono dla pozycji i rotacji gracza, rotacji wie¿yczki oraz prêdkoœci gracza. 

\texttt{Timer} ustawiony zosta³ na okres 0.3 sekundy. Co taki okres wysy³a on sygna³, który wywo³uje funkcjê synchronizuj¹c¹ wartoœci zmiennych puppet po sieci. W momencie ustawienia w ten sposób pozycji jest ona interpolowana z wykorzystaniem wêz³a \texttt{Tween}. Jest to implementacja za³o¿eñ z sekcji \ref{sec:concept_prediction}. Postaæ gracza wysy³a wtedy wartoœæ swoich rzeczywistych zmiennych. Awatar gracza w grze pozosta³ych graczy w procesie fizycznym zmienia równie¿ rotacjê cia³a i wie¿yczki. Je¿eli \texttt{Tween} nie jest aktywny, postaæ jest przemieszczana z prêdkoœci¹ otrzyman¹ z sieci. Jest to implementacja predykcji klienckich, równie¿ z sekcji \ref{sec:concept_prediction}.


\section{Wnioski}

Zgodnie z za³o¿eniami, przygotowanie prototypu pozwoli³o zapoznaæ siê z zawi³oœciami silnika Godot oraz zlokalizowaæ przysz³e trudnoœci. 

Implementacja podstawowych mechanik nie bêdzie stanowiæ wiêkszych trudnoœci. Zostan¹ one zaimplementowane w sposób zbli¿ony do tego z prototypu. Po³¹czenie sieciowe bêdzie stanowi³o najwiêksze wyzwanie. Aby jego implementacja przebieg³a sprawnie niezbêdny bêdzie dok³adny projekt modelu danych oraz ich przep³ywu przez sieæ. Jednak zastosowanie wysokopoziomowej warstwy sieciowej silnika Godot pozwoli znacznie uproœciæ ca³y system sieciowy.


